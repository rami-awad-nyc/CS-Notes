## Paging: Introduction

OS takes two approaches to solve space-management problem:  
1. Chop space into variable-sized pieces (segmentation) -- code, heap, stack
each as segments; this is flawed because even different sized chunks can get
fragmented.   
2. Chop space into fixed-sized pieces (paging). Each fixed-sized unit is a
*page* and physical memory is an array of fixed-sized slots called *page
frames*. Each frame contains a single page.

### Overview

Paging provides *flexibility*. We won't make asssumptions about the direction
the heap and stack grow and how they are used.  
Also, paging provides *simplicity*. If an address space needs to be placed in
memory, it is divided into pages and stored in free pages. 

To record where each virtual page of the address space is placed in memory, the
OS keeps a per-process data structure called a *page table*. The page table
stores address translations for each of the virtual pages of the address space.
For example: it would tell us that virtual page 3 goes in physical frame 7.
Remember: the page table here is per-process. If another process were to run, it
would need to its own page table to map virtual pages to memory. 

To translate a virtual address that is generated by a process, we have to split
it into two components: a *virtual page number (VPN)* and the *offset* within
the page. 

The number of bits for the offset depends on the page size. If page size is 16
bytes then there need to be 4 bits (2^4=16) to represent each address in the
page. 

The address space divided by the page size tells us how many pages are needed.
This is used to figure out how many bits represent the VPN. For example, 64-byte
address space / 16-byte page size gives 4 pages. We can represent four pages with
2 bits (2^2=4).

The page table tells us which physical frame a virtual page resides in. The
physical address after an address translation is made up of a *physical frame
number (PFN)* or *physical page number (PPN)* that is obtained through a page
table and an offset, that is the same as the virtual page offset. So, really, a
page table translates VPN to PPN.

### Where Are Page Tables Stored?

Page tables can get very large. Each page table entry might take up a few bytes
to store physical translation and other useful stuff, meaning a page table might
be massive. If many processes are running, the sum of the bytes their page
tables take up could be huge. 

Page tables are stored somewhere in memory. Let's assume the page tables live in
physical memory that the OS manages. Later, we see that OS memory can be
virtualized, so page tables can be stored in OS virtual memory.

### What's in a Page Table?

Simplest form is the *linear page table* or just an array. The OS indexes the
array by the VPN and looks up the PTE at that index in order to find the desired
PFN. 

Each PTE has many bits worth understanding:  
- *Valid bit* indicates whether a translation is valid. Unused space between
  the stack and heap are marked invalid, and memory access operations on memory
  addresses here will generate a trap to the OS. 
- *Protection bits* indicate whether the page could be read from, written to, or
  executed from.  
- *Present bit* indicates whether this page is in physical memory or on disk
  (i.e. it has been *swapped out*). Swapping address spaces larger than physical
  memory to the disk allows the OS to free up physical memory by moving rarely
  used memory to the disk.  
- *Dirty bit* indicates whether the page has been modified since brought to
  memory.  
- *Reference bit (access bit)* tracks whether a page has been accessed. 

### Paging: Also Too Slow

Assume that a single *page-table base register* contains the physical address of
the starting location of the page table in memory (where the page table is
located). 

Here we see how address translation can be slow: first, get VPN from VA. Then,
use page table base register and VPN index to get PTE address in memory. Then
fetch the PTE using the PTE address. After that, check valid, protection, etc
bits to see if the page can be accessed. If it can, then calculate offset from
VA and use the PTE to get the PPN. Now combine them to get physical address.
Lastly, fetch the data at the physical address.

This is a lot of instructions!
Page tables without proper design are slow and take up a lot of memory. 

